# Hash Tables
A hash table is a list-like data structure that’s designed to quickly store and retrieve key data records. To store keys in a hash table, they must be mapped (with a hash function) to the set of possible indices in the table or to addresses of a memory location.
- to store key-value pairs
- they are like arrays but the keys are not ordered
- fast for finding values, adding new values, and removing values, unlike arrays


## Hashing
hashing refers to the process of taking a key (i.e., a piece of data), scrambling it with an algorithm, and producing an index that’s used to sort the key into a hash table

## Hash function
- to look up values by key, we need hash function to convery keys into valid array indices
- A hash function is the algorithm that scrambles keys in order to produce indices.
- hash functions can take lots of different forms
- There’s only one absolute rule: 
    - For the same input, the function should always return the same output. 
    - The rest are just general guidelines to follow when creating a hash function:
        - It should be simple and efficient.
        - It should distribute values evenly throughout the hash table.
        - It should avoid collisions.

## Collisions
- for the same input, it must always generate the same output.
- but two different inputs could have the same output = collision
- Solve collisions with:
    - Open addressing (aka, probing).
        - If the index generated for a key is already taken, jump to somewhere else in the table to store your key.
        - The three most common types of open addressing are:
            - linear probing
            - quadratic probing
            - double hashing
    - Closed addressing (aka, chaining).


### Linear Probing
If the slot at the hashed index is occupied, look one slot to the right. Keep doing this until an open slot is found.

If the hash function isn’t set up carefully, this can cause what’s known as clustering, meaning that keys will be clumped together instead of distributed evenly. This is a problem, because indices are more likely to have to iterate through the cluster to reach an open space as opposed to coming across open spaces scattered neatly throughout the table.

### Quadratic Probing
If the slot at the hashed index is occupied, square the number of steps you take to the right (i.e., take one step, then four, then nine, then 16, then 25, etc.) until you find an open slot.

For example: If index 7 is taken, try 8. If index 8 is taken, try 12. If 12 is taken, try 21, then 37, and so on.

### Double Hashing
Come up with a secondary hash function. It must not ever return 0 and it must be able to return all addresses in the table.

If the slot at first index generated by (hash(x)) is occupied, hash that index using the secondary hash function (e.g., hash2(x)). If that slot is occupied, try 2 * hash2(x), then 3 * hash2(x), and so on.
